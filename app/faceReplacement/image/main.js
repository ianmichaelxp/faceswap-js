 /**
 * Ian Michael - https://github.com/ianmichaelxp
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

"use strict";const SETTINGS={artPainting:"images/images/neymar.jpg",detectState:{x:-.00636,y:.1208,s:.18629,ry:-.0429},nDetectsArtPainting:25,detectArtPaintingThreshold:.7,artPaintingMaskScale:[1.3,1.5],artPaintingMaskOffset:[-.2,.1],artPaintingCropSmoothEdge:.25,artPaintingHeadForheadY:.7,artPaintingHeadJawY:.5,videoDetectSizePx:1024,faceRenderSizePx:256,zoomFactor:1.03,detectionThreshold:.8,detectionHysteresis:.03,hueTextureSizePx:4,debugArtpaintingCrop:!1,debugArtPaintingPotFaceCutTexture:!1},ARTPAINTING={baseTexture:null,potFaceCutTexture:null,potFaceCutTextureSizePx:0,hueTexture:null,detectCounter:0,image:new Image,canvasMask:null,url:-1,positionFace:[0,0],scaleFace:[1,1],detectedState:null},USERCROP={faceCutDims:[0,0],potFaceCutTexture:null,hueTexture:null},SHPS={cropUserFace:null,copy:null};let DOMARTPAINTINGCONTAINER=null,GL=null,GLDRAWTARGET=null,FBO=null,NLOADEDS=0,FFSPECS=null;const STATES={ERROR:-1,IDLE:0,LOADING:1,DETECTARTPAINTINGFACE:2,DETECTUSERFACE:3,BUSY:4,ARTPAINTINGFACEDETECTPROVIDED:5};let STATE=STATES.IDLE,ISUSERFACEDETECTED=!1;function main(){STATE=STATES.LOADING,build_carousel(),DOMARTPAINTINGCONTAINER=document.getElementById("artpaintingContainer"),ARTPAINTING.image.src=SETTINGS.artPainting,ARTPAINTING.image.onload=check_isLoaded.bind(null,"ARTPAINTING.image"),JEEFACEFILTERAPI.init({canvasId:"jeeFaceFilterCanvas",NNCPath:"public/neuralNets/",callbackReady:function(e,t){if(e)return console.log("AN ERROR HAPPENS. ERROR CODE =",e),void(STATE=STATES.ERROR);FFSPECS=t,GL=t.GL,FBO=GL.createFramebuffer(),GLDRAWTARGET=GL.DRAW_FRAMEBUFFER?GL.DRAW_FRAMEBUFFER:GL.FRAMEBUFFER,console.log("INFO: JEEFACEFILTERAPI IS READY"),check_isLoaded("JEEFACEFILTERAPI")},callbackTrack:callbackTrack})}function check_isLoaded(e){console.log("INFO in check_isLoaded(): ",e,"is loaded"),2==++NLOADEDS&&start()}function start(){console.log("INFO: start()"),create_textures(),build_shps(),update_artPainting(SETTINGS.detectState)}function update_artPainting(e){FFSPECS.canvasElement.width=ARTPAINTING.image.width,FFSPECS.canvasElement.height=ARTPAINTING.image.height,JEEFACEFILTERAPI.resize(),ARTPAINTING.baseTexture||(ARTPAINTING.baseTexture=GL.createTexture()),GL.bindTexture(GL.TEXTURE_2D,ARTPAINTING.baseTexture),GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL,!0),GL.texImage2D(GL.TEXTURE_2D,0,GL.RGBA,GL.RGBA,GL.UNSIGNED_BYTE,ARTPAINTING.image),GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MAG_FILTER,GL.LINEAR),GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MIN_FILTER,GL.LINEAR),GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_WRAP_S,GL.CLAMP_TO_EDGE),GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_WRAP_T,GL.CLAMP_TO_EDGE),JEEFACEFILTERAPI.set_inputTexture(ARTPAINTING.baseTexture,ARTPAINTING.image.width,ARTPAINTING.image.height),ARTPAINTING.detectCounter=0,FFSPECS.canvasElement.classList.remove("canvasDetected"),FFSPECS.canvasElement.classList.remove("canvasNotDetected"),FFSPECS.canvasElement.classList.add("artPainting"),FFSPECS.canvasElement.style.top="",FFSPECS.canvasElement.style.left="",FFSPECS.canvasElement.style.width="",toggle_carousel(!0),e?(STATE=STATES.ARTPAINTINGFACEDETECTPROVIDED,ARTPAINTING.detectedState=e):STATE=STATES.DETECTARTPAINTINGFACE}function build_carousel(){$("#carousel").slick({speed:300,slidesToShow:1,centerMode:!0,variableWidth:!0,arrows:!1,swipeToSlide:!0,infinite:!1,focusOnSelect:!0}),toggle_carousel(!1)}function toggle_carousel(e){e?$("#carousel").css({opacity:1,pointerEvents:"auto"}):$("#carousel").css({opacity:.5,pointerEvents:"none"})}function change_artPainting(e,t){if(e!==ARTPAINTING.url&&-1!==[STATES.DETECTARTPAINTINGFACE,STATES.DETECTUSERFACE].indexOf(STATE))if(void 0===t&&(t=null),STATE=STATES.BUSY,toggle_carousel(!1),ARTPAINTING.canvasMask&&(ARTPAINTING.canvasMask.parentElement.removeChild(ARTPAINTING.canvasMask),ARTPAINTING.canvasMask=null),ARTPAINTING.image=new Image,"CUSTOM"===e){const e=document.getElementById("customImage");if(!e.files||!e.files[0])return void alert("You should select at least one file");const a=new FileReader;a.onload=function(e){ARTPAINTING.url="CUSTOM"+Date.now(),ARTPAINTING.image.src=e.target.result,ARTPAINTING.image.onload=update_artPainting.bind(null,t)},a.readAsDataURL(e.files[0])}else ARTPAINTING.url=e,ARTPAINTING.image.src=e,ARTPAINTING.image.onload=update_artPainting.bind(null,t)}function create_textures(){const e=function(e,t){const a=GL.createTexture();return GL.bindTexture(GL.TEXTURE_2D,a),GL.texImage2D(GL.TEXTURE_2D,0,GL.RGBA,e,t,0,GL.RGBA,GL.UNSIGNED_BYTE,null),a},t=function(){return function(t,a){const r=e(t,a);return GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MAG_FILTER,GL.LINEAR),GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MIN_FILTER,GL.LINEAR),r}(SETTINGS.hueTextureSizePx,SETTINGS.hueTextureSizePx)};ARTPAINTING.hueTexture=t(),USERCROP.hueTexture=t();const a=SETTINGS.artPaintingMaskScale[1]/SETTINGS.artPaintingMaskScale[0];USERCROP.faceCutDims[0]=SETTINGS.faceRenderSizePx,USERCROP.faceCutDims[1]=Math.round(SETTINGS.faceRenderSizePx*a),USERCROP.potFaceCutTexture=e(SETTINGS.faceRenderSizePx,SETTINGS.faceRenderSizePx),GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MAG_FILTER,GL.LINEAR),GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MIN_FILTER,GL.LINEAR_MIPMAP_NEAREST)}function build_artPaintingMask(e,t){console.log("INFO: build_artPaintingMask()");const a=e.x,r=e.y,n=e.s,o=e.ry,T=.5*a+.5+n*SETTINGS.artPaintingMaskOffset[0]*Math.sin(o),i=.5*r+.5+n*SETTINGS.artPaintingMaskOffset[1],c=n*SETTINGS.artPaintingMaskScale[0],s=n*SETTINGS.artPaintingMaskScale[1]*ARTPAINTING.image.width/ARTPAINTING.image.height;ARTPAINTING.positionFace[0]=T,ARTPAINTING.positionFace[1]=i,ARTPAINTING.scaleFace[0]=c,ARTPAINTING.scaleFace[1]=s,GL.useProgram(SHPS.buildMask.program),GL.uniform2f(SHPS.buildMask.offset,T,i),GL.uniform2f(SHPS.buildMask.scale,c,s),GL.activeTexture(GL.TEXTURE0),GL.bindTexture(GL.TEXTURE_2D,ARTPAINTING.baseTexture),GL.enable(GL.BLEND),GL.blendFunc(GL.SRC_ALPHA,GL.ZERO),GL.clearColor(0,0,0,0),GL.clear(GL.COLOR_BUFFER_BIT),GL.drawElements(GL.TRIANGLES,3,GL.UNSIGNED_SHORT,0),GL.disable(GL.BLEND);const E=document.createElement("canvas");E.width=ARTPAINTING.image.width,E.height=ARTPAINTING.image.height,E.getContext("2d").drawImage(FFSPECS.canvasElement,0,0),E.classList.add("artPainting"),FFSPECS.canvasElement.classList.remove("artPainting"),FFSPECS.canvasElement.classList.add("canvasNotDetected"),ISUSERFACEDETECTED=!1,ARTPAINTING.canvasMask=E,DOMARTPAINTINGCONTAINER.appendChild(E),SETTINGS.debugArtPaintingPotFaceCutTexture&&(E.style.opacity="0.5");const S=Math.round(ARTPAINTING.image.width*c),l=Math.round(ARTPAINTING.image.height*s),G=Math.max(S,l);ARTPAINTING.potFaceCutTextureSizePx=Math.pow(2,Math.ceil(Math.log(G)/Math.log(2))),ARTPAINTING.potFaceCutTexture=GL.createTexture(),GL.bindTexture(GL.TEXTURE_2D,ARTPAINTING.potFaceCutTexture),GL.texImage2D(GL.TEXTURE_2D,0,GL.RGBA,ARTPAINTING.potFaceCutTextureSizePx,ARTPAINTING.potFaceCutTextureSizePx,0,GL.RGBA,GL.UNSIGNED_BYTE,null),GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MAG_FILTER,GL.LINEAR),GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MIN_FILTER,GL.LINEAR_MIPMAP_NEAREST),GL.useProgram(SHPS.cropUserFace.program),GL.uniform2f(SHPS.cropUserFace.offset,T,i),GL.uniform2f(SHPS.cropUserFace.scale,c,s),GL.uniformMatrix2fv(SHPS.cropUserFace.videoTransformMat2,!1,[.5,0,0,.5]),GL.bindFramebuffer(GLDRAWTARGET,FBO),GL.bindTexture(GL.TEXTURE_2D,ARTPAINTING.baseTexture),GL.viewport(0,0,ARTPAINTING.potFaceCutTextureSizePx,ARTPAINTING.potFaceCutTextureSizePx),GL.framebufferTexture2D(GL.FRAMEBUFFER,GL.COLOR_ATTACHMENT0,GL.TEXTURE_2D,ARTPAINTING.potFaceCutTexture,0),GL.drawElements(GL.TRIANGLES,3,GL.UNSIGNED_SHORT,0),GL.useProgram(SHPS.copyInvX.program),GL.viewport(0,0,SETTINGS.hueTextureSizePx,SETTINGS.hueTextureSizePx),GL.framebufferTexture2D(GL.FRAMEBUFFER,GL.COLOR_ATTACHMENT0,GL.TEXTURE_2D,ARTPAINTING.hueTexture,0),GL.bindTexture(GL.TEXTURE_2D,ARTPAINTING.potFaceCutTexture),GL.generateMipmap(GL.TEXTURE_2D),GL.drawElements(GL.TRIANGLES,3,GL.UNSIGNED_SHORT,0),GL.bindFramebuffer(GLDRAWTARGET,null),t()}function build_shps(){const e="attribute vec2 position;\n    varying vec2 vUV;\n    void main(void){\n      gl_Position = vec4(position, 0., 1.);\n      vUV = 0.5 + 0.5 * position;\n    }",t="precision lowp float;\n    uniform sampler2D samplerImage;\n    varying vec2 vUV;\n    \n    void main(void){\n      gl_FragColor = texture2D(samplerImage, vUV);\n    }",a=build_shaderProgram(e,"precision lowp float;\n      varying vec2 vUV;\n      uniform mat2 videoTransformMat2;\n      uniform sampler2D samplerVideo;\n      uniform vec4 uxysw;\n      \n      void main(void) {\n        vec2 uvVideoCentered = 2.0 * videoTransformMat2 * (vUV - 0.5);\n        vec3 colorVideo = texture2D(samplerVideo, 0.5 + uvVideoCentered).rgb;\n        vec2 pos = vUV*2.-vec2(1.,1.);\n        vec2 isInside = step(uxysw.xy-uxysw.zw, pos);\n        isInside *= step(pos, uxysw.xy+uxysw.zw);\n        vec2 blendCenterFactor = abs(pos-uxysw.xy)/uxysw.zw;\n        float alpha = isInside.x*isInside.y*pow(max(blendCenterFactor.x, blendCenterFactor.y), 3.);\n        vec3 color = mix(colorVideo, vec3(0.,0.6,1.), alpha);\n        gl_FragColor = vec4(color,1.);\n      }","SEARCH FACE");SHPS.search={program:a,samplerVideo:GL.getUniformLocation(a,"samplerVideo"),videoTransformMat2:GL.getUniformLocation(a,"videoTransformMat2"),uxysw:GL.getUniformLocation(a,"uxysw")},GL.useProgram(a),GL.uniform1i(SHPS.search.samplerVideo,0);const r=function(e,t){const a=GL.getUniformLocation(e,"samplerImage"),r=GL.getUniformLocation(e,"scale"),n=GL.getUniformLocation(e,"offset"),o=t?GL.getUniformLocation(e,"videoTransformMat2"):null;return GL.useProgram(e),GL.uniform1i(a,0),{scale:r,offset:n,videoTransformMat2:o,program:e}};let n="float alpha = 0.;\n      vec2 uv = (vUV-offset+s2)/(2.*s2); //uv normalized in the face\n      if (uv.y>UPPERHEADY){ // upper head: circle arc\n        vec2 uvc = (uv-vec2(0.5,UPPERHEADY))*vec2(1., 0.5/(1.-UPPERHEADY));\n        float alphaBorder = smoothstep(0.5-SMOOTHEDGE, 0.5, length(uvc));\n        float alphaCenter = smoothstep(UPPERHEADY, 1., uv.y);\n        alpha = mix(alphaCenter, alphaBorder, smoothstep(0.3, 0.4, abs(uv.x-0.5)));\n      } else if (uv.y<LOWERHEADY){ // lower head: circle arc \n        vec2 uvc = (uv-vec2(0.5, LOWERHEADY))*vec2(1., 0.5/LOWERHEADY);\n        alpha = smoothstep(0.5-SMOOTHEDGE, 0.5, length(uvc));\n      } else { // middle head: straight\n        vec2 uvc = vec2(uv.x-0.5, 0.);\n        alpha = smoothstep(0.5-SMOOTHEDGE, 0.5,length(uvc));\n      }\n";n+="float grayScale = dot(color, vec3(0.33,0.33,0.33));\n          if (alpha>0.01){\n            alpha = mix(pow(alpha, 0.5), pow(alpha, 1.5), smoothstep(0.1,0.5,grayScale));\n          }";const o=build_shaderProgram(e,"precision highp float;\n     uniform vec2 offset, scale;\n     uniform sampler2D samplerImage;\n     varying vec2 vUV;\n     \n     const float UPPERHEADY ="+SETTINGS.artPaintingHeadForheadY.toFixed(2)+";\n     const float LOWERHEADY ="+SETTINGS.artPaintingHeadJawY.toFixed(2)+";\n     const float SMOOTHEDGE ="+SETTINGS.artPaintingCropSmoothEdge.toFixed(2)+";\n     \n     \n     void main(void){\n       vec2 s2 = 0.5 * scale;\n       vec2 isFace = step(vUV, offset+s2)*step(offset-s2, vUV);\n       float isNotFace = 1. - isFace.x * isFace.y;\n       if (isNotFace>0.01){\n         gl_FragColor = texture2D(samplerImage, vUV); return;\n       }\n       vec3 color = texture2D(samplerImage, vUV).rgb;\n       float alpha = 0.;\n      vec2 uv = (vUV-offset+s2)/(2.*s2); //uv normalized in the face\n      if (uv.y>UPPERHEADY){ // upper head: circle arc\n        vec2 uvc = (uv-vec2(0.5,UPPERHEADY))*vec2(1., 0.5/(1.-UPPERHEADY));\n        float alphaBorder = smoothstep(0.5-SMOOTHEDGE, 0.5, length(uvc));\n        float alphaCenter = smoothstep(UPPERHEADY, 1., uv.y);\n        alpha = mix(alphaCenter, alphaBorder, smoothstep(0.3, 0.4, abs(uv.x-0.5)));\n      } else if (uv.y<LOWERHEADY){ // lower head: circle arc \n        vec2 uvc = (uv-vec2(0.5, LOWERHEADY))*vec2(1., 0.5/LOWERHEADY);\n        alpha = smoothstep(0.5-SMOOTHEDGE, 0.5, length(uvc));\n      } else { // middle head: straight\n        vec2 uvc = vec2(uv.x-0.5, 0.);\n        alpha = smoothstep(0.5-SMOOTHEDGE, 0.5,length(uvc));\n      }\nfloat grayScale = dot(color, vec3(0.33,0.33,0.33));\n          if (alpha>0.01){\n            alpha = mix(pow(alpha, 0.5), pow(alpha, 1.5), smoothstep(0.1,0.5,grayScale));\n          }       gl_FragColor = vec4(color, alpha);\n       "+(SETTINGS.debugArtpaintingCrop?"gl_FragColor = vec4(1.,0.,0.,1.);":"")+"\n     }","BUILD ARTPAINTING MASK");SHPS.buildMask=r(o,!1);const T=build_shaderProgram("attribute vec2 position;\n     uniform vec2 offset, scale;\n     varying vec2 vUV;\n     void main(void){\n      gl_Position = vec4(position, 0., 1.);\n      vUV = offset + 0.5 * position * scale;\n     }","precision lowp float;\n     uniform sampler2D samplerImage;\n     uniform mat2 videoTransformMat2;\n     varying vec2 vUV;\n     const float BORDER = 0.2;\n     \n     void main(void){\n       vec2 uvCentered = 2.0 * vUV - vec2(1.,1.);\n       float ruv = length(uvCentered);\n       vec2 uvn = uvCentered/ruv;\n       vec2 uvBorder = uvn * (1.-BORDER);\n       float isOutside = step(1.-BORDER, ruv);\n       uvCentered = mix(uvCentered, uvBorder, isOutside);\n       vec2 uvVideoCentered = videoTransformMat2 * uvCentered;\n       gl_FragColor = texture2D(samplerImage, 0.5 + uvVideoCentered);\n     }","CUT ARTPAINTING FACE");SHPS.cropUserFace=r(T,!0);const i=build_shaderProgram(e,t,"COPY");SHPS.copy={program:i};let c=GL.getUniformLocation(i,"samplerImage");GL.useProgram(i),GL.uniform1i(c,0);const s=build_shaderProgram(e.replace("vUV = 0.5 + 0.5 * position","vUV = 0.5 + vec2(-0.5,0.5)*position"),t,"COPYINVX");SHPS.copyInvX={program:s},c=GL.getUniformLocation(s,"samplerImage"),GL.useProgram(s),GL.uniform1i(c,0);const E=build_shaderProgram(e,"precision highp float;\n     uniform sampler2D samplerImage, samplerHueSrc, samplerHueDst;\n     uniform mat2 videoTransformMat2;\n     uniform vec2 offset, scale;\n     varying vec2 vUV;\n     const vec2 EPSILON2 = vec2(0.001, 0.001);\n     \n     vec3 rgb2hsv(vec3 c) { //from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n      vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n      vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n      vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n      float d = q.x - min(q.w, q.y);\n      float e = 1.0e-10;\n      return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n     }\n     \n     vec3 hsv2rgb(vec3 c) { //from https://github.com/hughsk/glsl-hsv2rgb \n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); \n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); \n      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); \n      //return c.z * normalize(mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y));\n     } \n     \n     void main(void){\n       // flip left-right:\n       vec2 uv = vec2(1.-vUV.x, vUV.y);\n       // get color in HSV format:\n       vec2 uvCut = uv * scale + offset - scale/2.;\n       uvCut = 0.5 + 2.0 * videoTransformMat2 * (uvCut - 0.5);\n       vec3 colorRGB = texture2D(samplerImage, uvCut).rgb;\n       vec3 colorHSV = rgb2hsv(colorRGB);\n       // compute color transform:\n       vec3 srcRGB = texture2D(samplerHueSrc, uv).rgb;\n       vec3 dstRGB = texture2D(samplerHueDst, uv).rgb;\n       vec3 srcHSV = rgb2hsv(srcRGB);\n       vec3 dstHSV = rgb2hsv(dstRGB);\n       // apply the transform:\n       vec2 factorSV = vec2(1.,0.8) * dstHSV.yz / (srcHSV.yz+EPSILON2);\n       factorSV = clamp(factorSV, vec2(0.3,0.3), vec2(3,3.));\n       float dHue = dstHSV.x - srcHSV.x;\n       vec3 colorHSVout = vec3(mod(1.0+colorHSV.x+dHue, 1.0), colorHSV.yz*factorSV);\n       colorHSVout = clamp(colorHSVout, vec3(0.,0.,0.), vec3(1.,1.,1));\n       // reconvert to RGB and output the color:\n       colorRGB = hsv2rgb(colorHSVout);\n       gl_FragColor = vec4(colorRGB, 1.);\n     }","FINAL RENDER FACE");SHPS.render={program:E,scale:GL.getUniformLocation(E,"scale"),offset:GL.getUniformLocation(E,"offset"),videoTransformMat2:GL.getUniformLocation(E,"videoTransformMat2")},c=GL.getUniformLocation(E,"samplerImage");const S=GL.getUniformLocation(E,"samplerHueSrc"),l=GL.getUniformLocation(E,"samplerHueDst");GL.useProgram(E),GL.uniform1i(c,0),GL.uniform1i(S,2),GL.uniform1i(l,1)}function reset_toVideo(){position_userCropCanvas(),window.addEventListener("resize",position_userCropCanvas,!1),FFSPECS.canvasElement.width=SETTINGS.videoDetectSizePx,FFSPECS.canvasElement.height=SETTINGS.videoDetectSizePx,JEEFACEFILTERAPI.resize(),JEEFACEFILTERAPI.reset_inputTexture(),STATE=STATES.DETECTUSERFACE}function compile_shader(e,t,a){const r=GL.createShader(t);return GL.shaderSource(r,e),GL.compileShader(r),GL.getShaderParameter(r,GL.COMPILE_STATUS)?r:(alert("ERROR IN "+a+" SHADER: "+GL.getShaderInfoLog(r)),console.log("Buggy shader source: \n",e),null)}function build_shaderProgram(e,t,a){const r=compile_shader(e,GL.VERTEX_SHADER,"VERTEX "+a),n=compile_shader(t,GL.FRAGMENT_SHADER,"FRAGMENT "+a),o=GL.createProgram();GL.attachShader(o,r),GL.attachShader(o,n),GL.linkProgram(o);const T=GL.getAttribLocation(o,"position");return GL.enableVertexAttribArray(T),o}function position_userCropCanvas(){console.log("INFO: position_userCropCanvas()");const e=FFSPECS.canvasElement.style.position;FFSPECS.canvasElement.style.position="absolute";let t=ARTPAINTING.image.height*ARTPAINTING.positionFace[1],a=ARTPAINTING.image.width*ARTPAINTING.positionFace[0],r=ARTPAINTING.image.width*ARTPAINTING.scaleFace[0],n=ARTPAINTING.image.height*ARTPAINTING.scaleFace[1],o=r*SETTINGS.videoDetectSizePx/SETTINGS.faceRenderSizePx;t=ARTPAINTING.image.height-t;const T=DOMARTPAINTINGCONTAINER.getBoundingClientRect().width/ARTPAINTING.image.width;t*=T,a*=T,o*=T,t-=(n*=T)/2,a-=(r*=T)/2,FFSPECS.canvasElement.style.top=Math.round(t).toString()+"px",FFSPECS.canvasElement.style.left=Math.round(a).toString()+"px",FFSPECS.canvasElement.style.width=Math.round(o).toString()+"px",FFSPECS.canvasElement.style.position=e}function draw_search(e){GL.useProgram(SHPS.search.program),GL.viewport(0,0,FFSPECS.canvasElement.width,FFSPECS.canvasElement.height),GL.uniform4f(SHPS.search.uxysw,e.x,e.y,e.s,e.s*FFSPECS.canvasElement.width/FFSPECS.canvasElement.height),GL.uniformMatrix2fv(SHPS.search.videoTransformMat2,!1,FFSPECS.videoTransformMat2),GL.activeTexture(GL.TEXTURE0),GL.bindTexture(GL.TEXTURE_2D,FFSPECS.videoTexture),GL.drawElements(GL.TRIANGLES,3,GL.UNSIGNED_SHORT,0)}function draw_render(e){GL.bindFramebuffer(GLDRAWTARGET,FBO);const t=e.s/SETTINGS.zoomFactor,a=.5*e.x+.5+t*SETTINGS.artPaintingMaskOffset[0]*Math.sin(e.ry),r=.5*e.y+.5+t*SETTINGS.artPaintingMaskOffset[1],n=t*SETTINGS.artPaintingMaskScale[0],o=t*SETTINGS.artPaintingMaskScale[1];GL.useProgram(SHPS.cropUserFace.program),GL.framebufferTexture2D(GL.FRAMEBUFFER,GL.COLOR_ATTACHMENT0,GL.TEXTURE_2D,USERCROP.potFaceCutTexture,0),GL.uniform2f(SHPS.cropUserFace.offset,a,r),GL.uniform2f(SHPS.cropUserFace.scale,n,o),GL.uniformMatrix2fv(SHPS.cropUserFace.videoTransformMat2,!1,FFSPECS.videoTransformMat2),GL.viewport(0,0,SETTINGS.faceRenderSizePx,SETTINGS.faceRenderSizePx),GL.bindTexture(GL.TEXTURE_2D,FFSPECS.videoTexture),GL.drawElements(GL.TRIANGLES,3,GL.UNSIGNED_SHORT,0),GL.useProgram(SHPS.copy.program),GL.framebufferTexture2D(GL.FRAMEBUFFER,GL.COLOR_ATTACHMENT0,GL.TEXTURE_2D,USERCROP.hueTexture,0),GL.viewport(0,0,SETTINGS.hueTextureSizePx,SETTINGS.hueTextureSizePx),GL.bindTexture(GL.TEXTURE_2D,USERCROP.potFaceCutTexture),GL.generateMipmap(GL.TEXTURE_2D),GL.drawElements(GL.TRIANGLES,3,GL.UNSIGNED_SHORT,0),GL.bindFramebuffer(GLDRAWTARGET,null),GL.useProgram(SHPS.render.program),GL.uniform2f(SHPS.render.offset,a,r),GL.uniform2f(SHPS.render.scale,n,o),GL.uniformMatrix2fv(SHPS.render.videoTransformMat2,!1,FFSPECS.videoTransformMat2),GL.bindTexture(GL.TEXTURE_2D,FFSPECS.videoTexture),GL.activeTexture(GL.TEXTURE1),GL.bindTexture(GL.TEXTURE_2D,ARTPAINTING.hueTexture),GL.activeTexture(GL.TEXTURE2),GL.bindTexture(GL.TEXTURE_2D,USERCROP.hueTexture),GL.activeTexture(GL.TEXTURE0),GL.viewport(0,SETTINGS.videoDetectSizePx-USERCROP.faceCutDims[1],USERCROP.faceCutDims[0],USERCROP.faceCutDims[1]),GL.drawElements(GL.TRIANGLES,3,GL.UNSIGNED_SHORT,0),SETTINGS.debugArtPaintingPotFaceCutTexture&&(GL.useProgram(SHPS.copy.program),GL.bindTexture(GL.TEXTURE_2D,ARTPAINTING.potFaceCutTexture),GL.drawElements(GL.TRIANGLES,3,GL.UNSIGNED_SHORT,0))}function callbackTrack(e){switch(STATE){case STATES.DETECTARTPAINTINGFACE:if(e.detected>SETTINGS.detectArtPaintingThreshold&&++ARTPAINTING.detectCounter>SETTINGS.nDetectsArtPainting){const t=function(e){return Math.round(1e5*e)/1e5};return console.log("FACE DETECTED IN THE BASE PICTURE. detectState = "+JSON.stringify({x:t(e.x),y:t(e.y),s:t(e.s),ry:t(e.ry)}).replace(/"/g,"")),STATE=STATES.BUSY,void build_artPaintingMask(e,reset_toVideo)}draw_search(e);break;case STATES.ARTPAINTINGFACEDETECTPROVIDED:STATE=STATES.BUSY,build_artPaintingMask(ARTPAINTING.detectedState,reset_toVideo);break;case STATES.DETECTUSERFACE:ISUSERFACEDETECTED&&e.detected<SETTINGS.detectionThreshold-SETTINGS.detectionHysteresis?(ISUSERFACEDETECTED=!1,FFSPECS.canvasElement.classList.remove("canvasDetected"),FFSPECS.canvasElement.classList.add("canvasNotDetected")):!ISUSERFACEDETECTED&&e.detected>SETTINGS.detectionThreshold+SETTINGS.detectionHysteresis&&(ISUSERFACEDETECTED=!0,FFSPECS.canvasElement.classList.remove("canvasNotDetected"),FFSPECS.canvasElement.classList.add("canvasDetected")),ISUSERFACEDETECTED?draw_render(e):draw_search(e)}}